var testCase = {    name: "REST Return Selection",// REST Return selection: la commande retourne-t-elle une collection de même taille que la collection retournée en interrogeant directement le datastore ?// Pour un REST Return selection appelé dans une méthode de portée Table  testReceiveSelectionFrom4D_TableScope: function() {        var fullCollection;        fullCollection = ds.WikiStuff.all();        var aSelection;        aSelection = ds.WikiStuff.getSelectionFromTable();        if (fullCollection.length != aSelection.length) {            Y.Assert.fail("incorrect selection size: " + aSelection.length);        }    },// REST Return selection: la commande retourne-t-elle une collection de même taille que la collection retournée en interrogeant directement le datastore ?// Pour un REST Return selection appelé dans une méthode de portée la sélection courante  testReceiveSelectionFrom4D_SelectionScope: function() {        var aCollection;        aCollection = ds.WikiStuff.query('fS255 == :1', 'a@');        var aSelection;        aSelection = ds.WikiStuff.query('ID == :1', 1).getSelectionFromSelection('a');        if (aCollection.length != aSelection.length) {            Y.Assert.fail("incorrect selection size: " + aSelection.length);        }    },        // REST Return selection: la commande retourne-t-elle une collection de même taille que la collection retournée en interrogeant directement le datastore ?// Pour un REST Return selection appelé dans une méthode de portée l'enregistrement courant  testReceiveSelectionFrom4D_RecordScope: function() {        var aCollection;        aCollection = ds.WikiStuff.query('fS255 == :1', 'a@');        var aSelection;        aSelection = ds.WikiStuff.find('ID == :1', 1).getSelectionFromRecord('a');        if (aCollection.length != aSelection.length) {            Y.Assert.fail("incorrect selection size: " + aSelection.length);        }    },    // REST Return selection: on vérifie qu'il est possible de retourner une collection n'appartenant pas à la table à laquelle est liée la méthode REST appelée// On vérifie que la collection retournée a la même taille qu'une collection obtenue en interrogeant directement le datastore.       testReceiveSelectionFrom4D_AnotherTable: function() {        var aCollection;		aCollection = ds.LanguageCodes.query('Link_1_return.Link_2.Area == "Europe"');        var aSelection;        aSelection = ds.CountryCodes.query('Area == :1', 'Europe').getLanguageFromArea();        if (aCollection.length != aSelection.length) {            Y.Assert.fail("incorrect selection size: " + aSelection.length);        }    },    // On vérifie que la commande REST Return collection peut retourner une collection de taille nulle       testReceiveEmptySelectionFrom4D: function() {    	var aCollection;		aCollection = ds.WikiStuff.query('ID == :1', -1);    	var aSelection;        aSelection = ds.WikiStuff.getSelectionEmpty();        if (0 != aSelection.length) {            Y.Assert.fail("incorrect selection size: " + aSelection.length);        }    },            // On vérifie que REST Return selection peut retourner une collection avec plus de 14000 éléments    // On vérifie que le premier et le dernier élément de cette collection sont bien les mêmes que ceux retournés en interrogeant directement le datastore.    testReceiveBigSelectionFrom4D: function() {              var colDataStore;		colDataStore = ds.SeaMounts.all();		var colRESTReturn;		colRESTReturn = ds.SeaMounts.getSeaMounts();		var stampDataStore;		var indice = colDataStore.length - 1;		stampDataStore = colDataStore[indice].fS255 + " " + colDataStore[0].fS255; 		var stampRESTReturn;		indice = colRESTReturn.length - 1;		stampRESTReturn = colRESTReturn[indice].fS255 + " " + colRESTReturn[0].fS255;		if (stampDataStore !== stampRESTReturn) {            Y.Assert.fail("Bad selection returned from REST Return selection" + stampRESTReturn);		}    },        // On vérifie que le paramètre Table employé dans la commande Rest Return selection est bien optionnel.    // http://doc.4d.com/4D-v14-R3-Upgrade-14-R3/Language/REST-Return-selection.301-1475663.en.html  	testReceiveSelectionFrom4D_TableScopeWithDefault: function() {        var fullCollection;        fullCollection = ds.WikiStuff.all();        var aSelection;        aSelection = ds.WikiStuff.getSelectionFromTableDefault();        if (fullCollection.length != aSelection.length) {            Y.Assert.fail("incorrect selection size: " + aSelection.length);        }    },        // On vérifie que la commande REST Return selection n'opère pas sur une table qui n'est pas publié en REST            testReceiveForbiddenSelection: function() {		var maCollection;		var myError;				myError = "";		    	try {			maCollection = ds.WikiStuff.getSelectionRefuse()		}		catch (event) {			myError = event.messages;		}            if (myError[0] != "The {Param1} datastore class is not a local one") {            Y.Assert.fail("An exception should be raised when trying to access a 4D table not published in REST: " + myError);        }    },            // On vérifie que la commande REST Return selection ne retourne pas dans les propriétés de la collection résultat un champ qui n'est pas publié en REST    testReceiveForbiddenField: function() {    	var maCollection;			maCollection = ds.LINANEEN.getSelectionWithForbiddenField("sa");		if (maCollection.hasOwnProperty('GERMAN')) {            Y.Assert.fail("a Field not published in REST should not be accessible ");		};    },        // REST Return selection: la commande retourne-t-elle la même collection qu'une collection retournée en interrogeant directement le datastore pour les champs de type texte ?// Pour un REST Return selection appelé dans une méthode de portée Table        testCollectionsEqual: function() {        var fullCollection;        fullCollection = ds.WikiStuff.all();        var aSelection;        aSelection = ds.WikiStuff.getSelectionFromTable();                        if (fullCollection.length == aSelection.length) {			for (i = 0; i < fullCollection.length; i++) {								var aText = fullCollection[i].fTxt;				var aText2 = aSelection[i].fTxt;								if (aText === aText2) {									} else {            		Y.Assert.fail("something is wrong here");				}						}			}		            }};