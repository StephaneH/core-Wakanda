/*global exports, require, waserver, wadebugger, storage, File, solution, include, directory, TextStream, XmlToJSON, logout, XMLHttpRequest, JSONToXml*/'use strict';include('./script/md5.js');var admin = require("newAdmin");function isRunning(path) {    return (solution.getFolder().path + solution.name + ".waSolution" === path);}function formatDate(date) {    var formatedDate = '' + date.toLocaleDateString();    formatedDate = formatedDate + ' ' + ('0' + date.getHours()).substr(-2, 2) + ':' + ('0' + date.getMinutes()).substr(-2, 2) + ':' + ('0' + date.getSeconds()).substr(-2, 2);    return formatedDate;}function getAppData(app) {    var i, dataFolder;    dataFolder = app.getItemsWithRole("dataFolder").files;    for (i = 0; i < dataFolder.length; i++) {        if (dataFolder[i].name === "data.waData") {            return dataFolder[i].path;        }    }}function startMaintenance(type, options) {    var date,        logFileStorage,        maintenanceResults;    switch (type) {    case "verify":                maintenanceResults = admin.Verify(options);        break;    case "repair":        maintenanceResults = admin.Repair(options);        break;    case "compact":        maintenanceResults = admin.Compact(options);        break;    case "backup":        maintenanceResults = admin.Backup(options);        break;    case "restore":        maintenanceResults = admin.Restore(options);        break;    }    date = new Date(maintenanceResults.file.date);    maintenanceResults.file.hash = hex_md5(maintenanceResults.file.path);    maintenanceResults.file.formatedDate = formatDate(date);    maintenanceResults.file.date = '' + date.getTime();    if (storage.tryLock()) {        logFileStorage = storage.getItem("logFilePathHash");        logFileStorage[maintenanceResults.file.hash] = maintenanceResults.file.path;        storage.setItem("logFilePathHash", logFileStorage);        storage.unlock();    }    return maintenanceResults;}function getSettingsFromSolution(sol) {    var str, file, stream, settings, settingsObject;    settings = {        database: {},        solution: {            directory: {},            serverStartup: {}        }    };    try {        file = sol.getSettingFile("database");        stream = TextStream(file, "read");        str = stream.read();        settingsObject = JSON.parse(XmlToJSON(str, "json-bag", "settings"));        if (settingsObject.hasOwnProperty("database") && settingsObject.database.length > 0) {            settings.database = settingsObject.database[0];        }        if (settingsObject.solution[0].hasOwnProperty("directory") && settingsObject.solution[0].directory.length > 0) {            settings.solution.directory = settingsObject.solution[0].directory[0];        }        if (settingsObject.solution[0].hasOwnProperty("serverStartup") && settingsObject.solution[0].serverStartup.length > 0) {            settings.solution.serverStartup = settingsObject.solution[0].serverStartup[0];        }    } catch (e) {        console.log("Error reading solution settings files", e);        settings = null;    }    return settings;}function getSolutionApplication(sol) {    var i,        app,        apps = [],        path;    if (sol && sol.applications) {        for (i = sol.applications.length - 1; i >= 0; i--) {            path = sol.applications[i].getFolder('path');            if (path.indexOf('Contents/Resources/Wakanda Admin/Wakanda Admin/') != -1) {                continue;            }            app = {                name: sol.applications[i].name,                path: path,                admin: sol.applications[i].administrator,                pattern: sol.applications[i].pattern,                httpServer: sol.applications[i].httpServer,                settings: sol.applications[i].settings,                waModel: sol.applications[i].getItemsWithRole("catalog").path,                waData: getAppData(sol.applications[i])            };            app.logFiles = {                "verify": [],                "repair": [],                "compact": [],                "backup": [],                "unknown": []            };            folderlog = Folder(app.path + 'Logs');            logFilePathHash = {};            folderlog.forEachFile(function(file) {                var hash, fileObject = {};                fileObject.name = file.name;                fileObject.formatedDate = formatDate(file.creationDate);                fileObject.date = '' + file.creationDate.getTime();                fileObject.path = file.path;                hash = hex_md5(file.path);                logFilePathHash[hash] = file.path;                fileObject.hash = hash;                if (file.name.substr(0, 6) === "verify") {                    app.logFiles.verify.push(fileObject);                } else if (file.name.substr(0, 6) === "repair") {                    app.logFiles.repair.push(fileObject);                } else if (file.name.substr(0, 7) === "compact") {                    app.logFiles.compact.push(fileObject);                } else if (file.name.substr(0, 6) === "backup") {                    app.logFiles.backup.push(fileObject);                } else {                    app.logFiles.unknown.push(fileObject);                }            });            if (storage.tryLock()) {                storage.setItem("logFilePathHash", logFilePathHash);                storage.unlock();            }            apps.push(app);        }    }    return apps;}exports.hasAdministrator = function () {    return directory.hasAdministrator();};exports.openRecentSolution = function (hash) {    var recentSolutions = storage.recentSolutions;    try {        if (recentSolutions.hasOwnProperty(hash)) {        	            return admin.openSolution(recentSolutions[hash].path);        } else {            throw "Cannot open this solution";        }    } catch (e) {        console.log("Error : ", e);        return false;    }};exports.getSettingJsonData = function (solutionPath, applicationName) {    var app, str, file, stream, settingXml, settingSolution;    if (solutionPath === null) {        solutionPath = solution.getFolder('path') + solution.name + ".waSolution";    }    try {        if (solution.getFolder('path') + solution.name + ".waSolution" === solutionPath) {            settingSolution = solution;        } else {            settingSolution = waserver.openSolution(solutionPath, 2);        } if (applicationName === null) {            file = settingSolution.getSettingFile("database");            stream = TextStream(file, "read");            str = stream.read();            settingXml = XmlToJSON(str, "json-bag", "settings");            stream.close();        } else {            app = settingSolution.getApplicationByName(applicationName);            if (app !== null) {                file = app.getSettingFile("project");                stream = TextStream(file, "read");                str = stream.read();                settingXml = XmlToJSON(str, "json-bag", "settings");                stream.close();            } else {                settingXml = null;            }        }    } catch (e) {} finally {        if (settingSolution !== null && settingSolution.getFolder('path') !== solution.getFolder('path')) {            settingSolution.close();        }    }    return settingXml;};exports.reloadModels = function (applicationNames) {    var i, modelReloaded, modelToReload, currentApplication, applicationsLength, applicationToReload;    modelReloaded = 0;    modelToReload = applicationNames.length;    applicationToReload = {};    applicationNames.forEach(function(value, index) {        applicationToReload[value] = 1;    });    if (solution !== null) {        applicationsLength = solution.applications.length;        if (applicationsLength > 0) {            i = 0;            while (modelReloaded < modelToReload && i < applicationsLength) {                currentApplication = solution.applications[i];                if (applicationToReload.hasOwnProperty(currentApplication.name)) {                    currentApplication.reloadModel();                    modelReloaded++;                }                i++;            }        }    }    return (modelReloaded === modelToReload);};exports.getRecentSolutions = function () {    var i,          // for loop index        path,       // solution path        pathHash,       // hash derived from solution path        recentSolutions,            // request result        recentlyOpenedSolution,     // recent solution list        recentSolutionsStorage;     // a saved list of recent solutions    recentlyOpenedSolution = waserver.recentlyOpenedSolutions();    recentSolutions = [];    recentSolutionsStorage = storage.getItem("recentSolutions") || {};    for (i = recentlyOpenedSolution.length - 1; i >= 0; i--) {        path = recentlyOpenedSolution[i].solutionFile.path;        if (File.isFile(path)) {            pathHash = hex_md5(path);            recentSolutionsStorage[pathHash] = {                name: recentlyOpenedSolution[i].name,                path: path            };            recentSolutions.push({                name: recentlyOpenedSolution[i].name,                hash: pathHash,                path: path,                isRunning: isRunning(path)            });        }    }    if (storage.tryLock()) {        storage.setItem("recentSolutions", recentSolutionsStorage);        storage.unlock();    }    return recentSolutions;};/* new name */exports.getSolutionDetails = function (hash) {    var response = {}, openedSol,        sol = storage.recentSolutions ? storage.recentSolutions[hash] : null;    try {        if (sol) {            openedSol = isRunning(sol.path) ? solution : waserver.openSolution(sol.path, 2);            response = {                name:  sol.name,                hash: hash,                apps: getSolutionApplication(openedSol),                path: sol.path,                isRunning: isRunning(sol.path),                isProtected: directory.hasAdministrator(),                settings: getSettingsFromSolution(openedSol)            };        }    } catch (ignore) {    } finally {        if (openedSol && openedSol !== solution) {            openedSol.close();        }    }    return response;};exports.verifyApplication = function (option) {    return startMaintenance('verify', {        applicationName: option.applicationName,        solutionPath: option.solutionPath    });};exports.repairApplication = function (option) {    return startMaintenance('repair', {        applicationName: option.applicationName,        solutionPath: option.solutionPath    });};exports.compactApplication = function (option) {    return startMaintenance('compact', {        applicationName: option.applicationName,        solutionPath: option.solutionPath    });};exports.backupApplication = function (option) {    return startMaintenance('backup', {        applicationName: option.applicationName,        solutionPath: option.solutionPath    });};exports.restoreApplication = function (option) {    return startMaintenance('restore', {        restoreDate: option.restoreDate,        solutionPath: option.solutionPath,        applicationName: option.applicationName    });};exports.closeSolution = function () {    var jobId = admin.closeSolution();    logout();    return jobId;};exports.openSolutionByPath = function (path) {    var file,        returnVal;    path = path.split("%20").join(" ");    file = new File(path);    if (!file.exists) {        return {            "error": "File not found",            "message": path + " is not found on the server"        };    }    returnVal = admin.openSolution(path);    logout();    return returnVal;};exports.saveSettingJsonData = function (solutionPath, applicationName, settingsJson) {    var app, file, stream, settingXml, settingSolution;    settingXml = JSONToXml(settingsJson, "json-bag", "settings");    try {        settingSolution = isRunning(solutionPath) ? solution : waserver.openSolution(solutionPath, 2);        if (applicationName === null) {            file = settingSolution.getSettingFile("database");        } else {            app = settingSolution.getApplicationByName(applicationName);            if (app !== null) {                file = app.getSettingFile("project");            }        }        if (file) {            stream = TextStream(file, "overwrite");            stream.write(settingXml);            stream.close();        }    } catch (e) {        return false;    } finally {        if (settingSolution && settingSolution !== solution) {            settingSolution.close();        }    }    return true;};exports.resetCache = function (projetName) {    var  port, url, ip, xhr, app, protocol, result;    app = solution.getApplicationByName(projetName);    if (!app) {        result =  {            status: 404,            text: "Application does not exist"        };    } else {        xhr     = new XMLHttpRequest();        ip      = app.httpServer.ipAddress;        port    = app.httpServer.ssl.enabled ? app.httpServer.ssl.port : app.httpServer.port;        protocol = app.httpServer.ssl.enabled ? 'https' : 'http';        url     = protocol + "://" + ip + ":" + port + "/waf-reset-build-cache";        xhr.open('GET', url, false);        xhr.send();        if (xhr.status === 200) {            result = {                status: xhr.status,                text: xhr.responseText            };        } else {            result = {                status: xhr.status,                text: xhr.responseText            };        }    }    return result;};exports.getLogMessages = function () {    var log;    log = {};    log.messages = console.content;    log.messages.forEach(function s(element, index, messageArray) {        messageArray[index] = element.replace(", HTTP connection handler", "");    });    return log;};exports.getMaintenanceLog = function (fromId) {    return admin.getMaintenanceLog(fromId);};exports.getProductName = function () {    return process.productName;};exports.quitServer = function () {    waserver.quitServer();};exports.getLocalIpAdresses = function () {    var i, returnArray, localInterface, interfaceLength, localInterfaces, localInterfaceName;    returnArray = [];    localInterfaces = os.networkInterfaces();    for (localInterfaceName in localInterfaces) {        localInterface = localInterfaces[localInterfaceName];        interfaceLength = localInterface.length;        for (i = 0; i < interfaceLength; i++) {            returnArray.push(localInterface[i].address);        }    }    return returnArray;};/* Debugger API */exports.setDebuggerServer = function (debugMode) {    var job = getJobManager().getJob();    wadebugger.setDebuggerServer(debugMode, job);    return job.id;};exports.getDebuggerServer = function () {    return wadebugger.getDebuggerServer();};exports.isDebugging = function () {    return wadebugger.isDebugging();};exports.startDebugger = function () {    return wadebugger.startDebugger();};exports.stopDebugger = function () {    return wadebugger.stopDebugger();};exports.canSetDebuggerServer = function (debugMode) {    return wadebugger.canSetDebuggerServer(debugMode);};exports.getDebuggerStatus = function (params) {    return wadebugger.getDebuggerStatus(params);};exports.getBreakpoints = function (params) {    return wadebugger.getBreakpoints(params);};exports.setBreakpoints = function (params) {    return wadebugger.setBreakpoints(params);};exports.updateBreakpoints = function (url, lineNumbers) {    return wadebugger.updateBreakpoints(url, lineNumbers);};exports.removeBreakpoints = function (params) {    return wadebugger.removeBreakpoints(params);};exports.getDebuggerPort = function () {    return wadebugger.getDebuggerConnection();};/* Services */exports.setService = function (applicationName, serviceName, enable) {    var service, application;    application = solution.getApplicationByName(applicationName);    service = application[serviceName];    (enable) ? service.enable() : service.disable();    return service.enabled;};exports.setServer = function (applicationName, serverName, start) {    var server, application;    application = solution.getApplicationByName(applicationName);    server = application[serverName];    (start) ? server.start() : server.stop();    return server.started;};exports.stopRPCForApp = function (appName) {    var app, rpcService;    app = solution.getApplicationByName(appName);    rpcService = require("services/rpc").getInstanceFor(app);    if ((rpcService !== null) && (typeof rpcService !== 'undefined')) {        rpcService.stop();        return !rpcService.isStarted();    }    return false;};exports.startRPCForApp = function (appName) {    var app, rpcService;    app = solution.getApplicationByName(appName);    rpcService = require("services/rpc").getInstanceFor(app);    if ((rpcService !== null) && (typeof rpcService !== 'undefined')) {        rpcService.start();        return rpcService.isStarted();    }    return false;};exports.stopDataServiceForApp = function (appName) {    var app, dataStoreService;    app = solution.getApplicationByName(appName);    dataStoreService = require("services/dataStore").getInstanceFor(app);    if ((dataStoreService !== null) && (typeof dataStoreService !== 'undefined')) {        dataStoreService.stop();        return !dataStoreService.isStarted();    }    return false;};exports.startDataServiceForApp = function (appName) {    var app, dataStoreService;    app = solution.getApplicationByName(appName);    dataStoreService = require("services/dataStore").getInstanceFor(app);    if ((dataStoreService !== null) && (typeof dataStoreService !== 'undefined')) {        dataStoreService.start();        return dataStoreService.isStarted();    }    return false;};exports.stopWebAppForApp = function (appName) {    var app, webAppService;    app = solution.getApplicationByName(appName);    webAppService = require("services/webApp").getInstanceFor(app);    if ((webAppService !== null) && (typeof webAppService !== 'undefined')) {        webAppService.stop();        return !webAppService.isStarted();    }    return false;};exports.startWebAppForApp = function (appName) {    var app, webAppService;    app = solution.getApplicationByName(appName);    webAppService = require("services/webApp").getInstanceFor(app);    if ((webAppService !== null) && (typeof webAppService !== 'undefined')) {        webAppService.start();        return webAppService.isStarted();    }    return false;};exports.stopHTTPServerForApp = function (appName) {    var app;    app = solution.getApplicationByName(appName);    if (app.httpServer.started) {        app.httpServer.stop();    }    return true; //return !app.httpServer.started;};exports.startHTTPServerForApp = function (appName) {    var app;    app = solution.getApplicationByName(appName);    if (!app.httpServer.started) {        app.httpServer.start();    }    return app.httpServer.started;};exports.stopSqlServerForApp = function (appName) {    var app;    app = solution.getApplicationByName(appName);    if (app.sqlServer.started) {        app.sqlServer.stop();    }    return !app.sqlServer.started;};exports.startSqlServerForApp = function (appName) {    var app;    app = solution.getApplicationByName(appName);    if (!app.sqlServer.started) {        app.sqlServer.start();    }    return app.sqlServer.started;};